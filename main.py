from fastapi import FastAPI, HTTPException, Request
from pydantic import BaseModel
from typing import Union, Optional
import os
import shutil

# LangChain / Groq imports
from langchain_groq import ChatGroq
from langchain_community.vectorstores import FAISS
from langchain_core.prompts import ChatPromptTemplate
from langchain_huggingface import HuggingFaceEmbeddings
from langchain_text_splitters import RecursiveCharacterTextSplitter
from langchain_community.document_loaders import PyPDFLoader
from langchain.indexes import VectorstoreIndexCreator
from langchain.chains import RetrievalQA

# --------------- FastAPI setup ---------------
app = FastAPI(title="RAG Chatbot API")

# --------------- Request/Response models ---------------
class ChatRequest(BaseModel):
    message: str
    # user_id can be string, int or None ‚Üí fixes validation issue
    user_id: Optional[Union[str, int]] = None  

class ChatResponse(BaseModel):
    reply: str

# --------------- Vectorstore (cached & persistent) ---------------
INDEX_FILE = "faiss_index"
PDF_FILE = "./Laundry_Services_Dataset.pdf"

def build_vectorstore():
    """Build a fresh FAISS index from the PDF."""
    embedding_model = HuggingFaceEmbeddings(
        model_name="sentence-transformers/all-MiniLM-L6-v2",
        model_kwargs={"device": "cpu"}
    )

    loaders = [PyPDFLoader(PDF_FILE)]
    index = VectorstoreIndexCreator(
        vectorstore_cls=FAISS,
        embedding=embedding_model,
        text_splitter=RecursiveCharacterTextSplitter(
            chunk_size=1000, chunk_overlap=100
        )
    ).from_loaders(loaders)

    index.vectorstore.save_local(INDEX_FILE)
    return index.vectorstore

def get_vectorstore():
    """Load FAISS index from disk or build if not exists."""
    embedding_model = HuggingFaceEmbeddings(
        model_name="sentence-transformers/all-MiniLM-L6-v2",
        model_kwargs={"device": "cpu"}
    )

    if os.path.exists(INDEX_FILE):
        print("üîπ Loading FAISS index from disk...")
        return FAISS.load_local(INDEX_FILE, embedding_model, allow_dangerous_deserialization=True)

    print("‚ö° Building new FAISS index...")
    return build_vectorstore()

# Cache vectorstore on startup
vectorstore = get_vectorstore()

# --------------- LLM Model setup ---------------
model = "llama-3.1-8b-instant"
groq_chat = ChatGroq(
    groq_api_key=os.environ.get("GROQ_API_KEY"),
    model_name=model
)

# Prompt template
groq_sys_prompt = ChatPromptTemplate.from_template(
    """You are very smart at everything. Always give the most accurate, precise, and professional answers.
    Answer the following Question: {user_prompt}.
    Keep answers direct and avoid unnecessary small talk."""
)

# --------------- Endpoints ---------------
@app.get("/health")
async def health():
    return {"status": "ok"}

@app.post("/chat", response_model=ChatResponse)
async def chat(req: ChatRequest, request: Request):
    """
    Main chat endpoint.
    Accepts message + optional user_id.
    Returns reply generated by Groq model with FAISS retrieval.
    """
    try:
        chain = RetrievalQA.from_chain_type(
            llm=groq_chat,
            chain_type="stuff",
            retriever=vectorstore.as_retriever(search_kwargs={"k": 3}),
            return_source_documents=False
        )

        result = chain.invoke({"query": req.message})
        response = result["result"]

        return ChatResponse(reply=response)

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/reload")
async def reload_vectorstore():
    """Rebuild FAISS index when PDF is updated."""
    global vectorstore
    try:
        # Delete old index if exists
        if os.path.exists(INDEX_FILE):
            shutil.rmtree(INDEX_FILE)
            print("üóëÔ∏è Old FAISS index deleted")

        # Rebuild
        vectorstore = build_vectorstore()
        return {
            "status": "reloaded",
            "message": "Vectorstore successfully rebuilt from new PDF."
        }

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Reload failed: {e}")
